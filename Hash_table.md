### Hash Table

**이번엔 해시테이블 자료구조에 대해 알아보겠다. 생각보다 깊게 팔수록 공부해야 하는게 많아지는 주제인 것 같다. 최대한 핵심적인 부분들만 모아 짧게 정리해보자.** 

#### 해시 테이블 (Hash Table)

**해시 테이블**은 연관배열의 구조로 key값을 value값과 함께 저장하는 자료구조이다.
- **연관배열(Associative Array)**
: **연관배열**이란 key값을 통해 value값을 찾을 수 있도록 key값과 value값을 1:1로 연관되어있는 배열을 말한다. 
파이썬에서 dictionary타입으로 연관배열을 선언할 수 있다.
```python
array = {}
array[key] = value
```

##### 해시테이블의 구조
해시 테이블을 이루고 있는 요소
- **키 (Key)**
: Hash 함수의 입력으로 들어가는 값. 고유한 값을 가진다.
- **해시함수 (Hash Function)**
: key값을 입력으로 받아 해싱을 해주는 함수이다. key값의 길이와는 상관없이 항상 같은 길이의 해시값을 출력으로 내뱉는다. 해시테이블의 효율성에 가장 큰 영향력을 미치는 요소이다.
- **해시 (Hash)**
: key값이 해시함수를 거쳐 얻은 값. 저장소에서 value값을 저장하는 주소로 쓰인다.
- **값 (Value)**
: 해시테이블의 key값, 해시 테이블의 저장소에서 hash값과 1:1로 대응되는 값이다. ( 이렇게 이해하는게 맞는지 모르겠다. )
- **저장소 (bucket)**
: 해시 테이블의 value값이 저장되는 실제 메모리 공간..?

대충 그림으로 해시테이블의 구조를 그려보았다..

<img src = "https://github.com/Wook-2/Breaking_CodingTest/blob/main/image/hash_table.PNG?raw=true" width = "400px">

##### 해시테이블의 연산
- **삽입 연산 (Insert)**
: key값을 받아 해시 함수를 거쳐 해시값을 추출한다. 해시값을 통해 저장소에 해시값과 value값이 1:1 대응되도록 삽입한다. 
```
key값의 개수가 n개일 때, 삽입연산의 시간복잡도는 O(1)이 된다.
최악의 경우에는 시간복잡도가 O(n)이 되는데 삽입을 하려는데 이미 해당 저장소에 다른 value값이 저장이 되어있다면 
중복저장을 피하기 위해 해시충돌을 해결해주어야 한다.
해시 충돌에 대해서는 아래에서 다시 설명하겠다.
아무튼 이렇게 해시충돌이 계속 발생하여 마지막에 남은 한자리를 찾게된다면 그 때는 시간복잡도가 O(n)이 된다.
```
- **삭제 연산 (Delete)**
: 저장소에서 key, hash값을 통해 value값을 찾아 삭제를 하면된다.
삭제연산도 시간복잡도는 O(1)이며, 최악의 경우O(n)이 된다.
- **탐색 연산 (Search)**
: 삭제연산과 동일하다. 저장소에서 key, hash값을 통해 value값을 찾아온다.
동일하게 시간복잡도는 O(1), 최악의 경우에 O(n)이 된다. 

##### 해시 충돌 (Hash Collision)
**해시 충돌**이란 key값을 통해 해시값을 구할 때 이미 다른 key값이 해당 해시값을 가지고 있는 상황을 말한다. 이런 경우 중복 저장을 방지하지 위해 여러가지 방법으로 새롭게 key값을 재해싱시켜주어야 한다.
해시 충돌을 해결하는 방법으로는 크게 **체이닝**, **개방 주소법** 으로 나뉘어진다.
- **체이닝 (Chaining)**
: **체이닝 기법**은 저장소에서 value가 들어가는 공간을 연결 리스트(Linked List)로 만들어 같은 해시값에 새로운 key에 대한 value값이 들어오려고 할 때, 연결 리스트를 통해 계속 이어준다.
- **개방 주소법 (Open Addressing)**
: **개방 주소법**은 체이닝 기법과는 달리 해시충돌이 일어났을 때 다른 해시주소를 가르키는 방식이다. 개방 주소법에도 여러가지 방법이 있는데 대표적으로 3가지만 소개하겠다.
	- 선형 탐색 (Linear Probing)
	: 선형 탐색은 해시 충돌이 발생했을 때, 바로 다음 주소, 혹은 n번째 뒤의 주소를 가르키는 방법이다.
	- 제곱 탐색 (Quadratic Probing)
	: 제곱 탐색은 해시 충돌이 발생했을 때, 제곱수(1, 4, 9, 16 ...)만큼 뛰어넘은 주소를 가르키는 방법이다.
	- 이중 해시 (Double Hashing)
	: 이중 해시는 해시 충돌이 발생했을 때, 새로운 해시함수를 한번 더 적용하여 새로운 해시값을 추출해주는 방법이다.

##### 파이썬에서의 해시테이블
파이썬에서 Dictionary타입이 내부적으로 해시테이블을 사용한다고 한다.
python dictionary를 키워드로 검색해보면 사용법을 쉽게 터득할 수 있을것이다.
여기서는 조금더 Low(?)하게 해시테이블을 구현해보겠다.
```python
bucket = list([-1 for i in range(10)]) # 크기가 10인 저장소를 선언
key = ['alpha', 'beta', 'gamma'] # 키값 선언
val = [1, 2, 3] # value값 선언

# 해시함수
def hash_func(h):
	return h%7

# 3개의 키값 삽입
for i in range(len(key)):
	h = hash_func(hash(key[i])) # hash() 내장함수로 key값을 인코딩하여 해시함수에 넣어줌.
	bucket[h] = val[i]

print(bucket) # 값들이 잘 저장되었는지 확인

# 키값으로 value값을 찾아주는 함수
def find_by_key(key, bucket):
	h = hash(key)
	h = hash_func(h)
	v = bucket[h]
	if v != -1:
		return v
	else:
		return "no data"

value = find_by_key('alpha', bucket)
print(value) # key값으로 value값을 제대로 찾는지 출력해보자

```
