### Hash Table

**이번엔 해시테이블 자료구조에 대해 알아보겠다. 생각보다 깊게 팔수록 공부해야 하는게 많아지는 주제인 것 같다. 최대한 핵심적인 부분들만 모아 짧게 정리해보자.** 

#### 해시 테이블 (Hash Table)

**해시 테이블**은 연관배열의 구조로 key값을 value값과 함께 저장하는 자료구조이다.
- **연관배열(Associative Array)**
: **연관배열**이란 key값을 통해 value값을 찾을 수 있도록 key값과 value값을 1:1로 연관되어있는 배열을 말한다. 
파이썬에서 dictionary타입으로 연관배열을 선언할 수 있다.
```python
array = {}
array[key] = value
```

##### 해시테이블의 구조
해시 테이블을 이루고 있는 요소
- **키 (Key)**
: Hash 함수의 입력으로 들어가는 값. 고유한 값을 가진다.
- **해시함수 (Hash Function)**
: key값을 입력으로 받아 해싱을 해주는 함수이다. key값의 길이와는 상관없이 항상 같은 길이의 해시값을 출력으로 내뱉는다. 해시테이블의 효율성에 가장 큰 영향력을 미치는 요소이다.
- **해시 (Hash)**
: key값이 해시함수를 거쳐 얻은 값. 저장소에서 value값을 저장하는 주소로 쓰인다.
- **값 (Value)**
: 해시테이블의 key값, 해시 테이블의 저장소에서 hash값과 1:1로 대응되는 값이다. ( 이렇게 이해하는게 맞는지 모르겠다. )
- **저장소 (bucket)**
: 해시 테이블의 value값이 저장되는 실제 메모리 공간..?

대충 그림으로 해시테이블의 구조를 그려보았다..

<img src = "https://github.com/Wook-2/Breaking_CodingTest/blob/main/image/hash_table.PNG?raw=true" width = "400px">

##### 해시테이블의 연산
- **삽입 연산 (Insert)**
: key값을 받아 해시 함수를 거쳐 해시값을 추출한다. 해시값을 통해 저장소에 해시값과 value값이 1:1 대응되도록 삽입한다. 
```
key값의 개수가 n개일 때, 삽입연산의 시간복잡도는 O(1)이 된다.
최악의 경우에는 시간복잡도가 O(n)이 되는데 삽입을 하려는데 이미 해당 저장소에 다른 value값이 저장이 되어있다면 
중복저장을 피하기 위해 해시충돌을 해결해주어야 한다.
해시 충돌에 대해서는 아래에서 다시 설명하겠다.
아무튼 이렇게 해시충돌이 계속 발생하여 마지막에 남은 한자리를 찾게된다면 그 때는 시간복잡도가 O(n)이 된다.
```
- **삭제 연산 (Delete)**
: 저장소에서 key, hash값을 통해 value값을 찾아 삭제를 하면된다.
삭제연산도 시간복잡도는 O(1)이며, 최악의 경우O(n)이 된다.
- **탐색 연산 (Search)**
: 삭제연산과 동일하다. 저장소에서 key, hash값을 통해 value값을 찾아온다.
동일하게 시간복잡도는 O(1), 최악의 경우에 O(n)이 된다. 

##### 해시 충돌 (Hash Collision)
**해시 충돌**이란 key값을 통해 해시값을 구할 때 이미 다른 key값이 해당 해시값을 가지고 있는 상황을 말한다. 이런 경우 중복 저장을 방지하지 위해 여러가지 방법으로 새롭게 key값을 재해싱시켜주어야 한다.
해시 충돌을 해결하는 방법으로는 크게 **체이닝**, **개방 주소법** 으로 나뉘어진다.
- **체이닝 (Chaining)**
: **체이닝 기법**은 저장소에서 value가 들어가는 공간을 연결 리스트(Linked List)로 만들어 같은 해시값에 새로운 key에 대한 value값이 들어오려고 할 때, 연결 리스트를 통해 계속 이어준다.
- **개방 주소법 (Open Addressing)**
: **개방 주소법**은 체이닝 기법과는 달리 해시충돌이 일어났을 때 다른 해시주소를 가르키는 방식이다. 개방 주소법에도 여러가지 방법이 있는데 대표적으로 3가지만 소개하겠다.
	- 선형 탐색 (Linear Probing)
	: 선형 탐색은 해시 충돌이 발생했을 때, 바로 다음 주소, 혹은 n번째 뒤의 주소를 가르키는 방법이다.
	- 제곱 탐색 (Quadratic Probing)
	: 제곱 탐색은 해시 충돌이 발생했을 때, 제곱수(1, 4, 9, 16 ...)만큼 뛰어넘은 주소를 가르키는 방법이다.
	- 이중 해시 (Double Hashing)
	: 이중 해시는 해시 충돌이 발생했을 때, 새로운 해시함수를 한번 더 적용하여 새로운 해시값을 추출해주는 방법이다.

##### 파이썬에서의 해시테이블
파이썬에서 Dictionary타입이 내부적으로 해시테이블을 사용한다고 한다.
python dictionary를 키워드로 검색해보면 사용법을 쉽게 터득할 수 있을것이다.
여기서는 조금더 Low(?)하게 해시테이블을 구현해보겠다.
```python
bucket = list([-1 for i in range(10)]) # 크기가 10인 저장소를 선언
key = ['alpha', 'beta', 'gamma'] # 키값 선언
val = [1, 2, 3] # value값 선언

# 해시함수
def hash_func(h):
	return h%7

# 3개의 키값 삽입
for i in range(len(key)):
	h = hash_func(hash(key[i])) # hash() 내장함수로 key값을 인코딩하여 해시함수에 넣어줌.
	bucket[h] = val[i]

print(bucket) # 값들이 잘 저장되었는지 확인

# 키값으로 value값을 찾아주는 함수
def find_by_key(key, bucket):
	h = hash(key)
	h = hash_func(h)
	v = bucket[h]
	if v != -1:
		return v
	else:
		return "no data"

value = find_by_key('alpha', bucket)
print(value) # key값으로 value값을 제대로 찾는지 출력해보자

```
<details>
    <summary>잡담</summary>

이만큼 내용을 정리하는데 꽤많은 시간이 걸렸는데 완성하고보니 그렇게 많아보이진 않는다 ㅋㅋ..
해당 내용들을 공부할 때 구글에서 많은 블로그들을 보게 되는데 정리를 깔끔하게 하시는분들 정말 대단한 것 같다.
해시 테이블 같은 경우도 학교에서 한번 배우고(무슨과목에서 배웠는지 기억이 잘 안난다,, 아마 자료구조? ) 머리속에서 잊혀졌는데, 실제로 구현을 해보니까 뭔가 신기했다., 코드를 보면 되게 대충 짠것 같다 ㅋㅋㅋ 근데 어차피 나만 보고 참고할 코드라서 크게 상관은 없겠지..? 아무튼 정신없는 와중에 무사히 해시테이블까지 정리를 끝냈다. 
음.. 정렬을 정리한 페이지에서 내가 이것들을 정리하는 이유가 이번주에 있을 코테 때문이라고 했었다. 그런데 공익에서 산업기능요원으로 편입하려면 ``1. 집안이 매우 어렵거나 2. 지병을 앓고 있어 1달이상 통원치료가 필요하거나`` 두가지 조건중 하나에 해당해야 하는데 해당사항이 없어서 결국 산업기능요원으로 편입은 무산되었다. 아쉬웠다, 굉장히 좋은기회였다.. 아쉽지만 한편으로는 마음이 편해졌다. 요즘 너무 힘들어서 그냥 쉬고싶다고만 했는데, 스타트업 회사에 가서 치열하게 공부하지 않고 동사무소에서 천천히 내 공부 하면서 쉴 수 있을것같다는 생각이 들었다.
코딩테스트는 보지 않게되었지만 아직 남아있는 여러 주제에 대한 내용정리는 계속 이어갈 생각이다. 나중에 여유가 생기면 개발자 블로그도 해보고 싶다는 생각도 들었다. 글쓰기에도 욕심이 생겼다. 나의 생각을 누군가가 보라고 올리는 것은 아니지만 누군가가 볼 수 있는 공간에 쓰는것이 생각보다 재밌고, 마음이 치유되는(?) 것 같다 ㅋㅋ;
끝으로 내가 잡담을 쓸때는 그냥 의식의 흐름대로 쓴다, 앞으로도 그럴것이다 ㅋㅋ 위에 내용을 정리할 때는 여러번 고치고 수정하고 옮기는데 잡담을 쓸때만큼은 그냥 그당시 기분을 나 편한대로 적어내리고 싶다. 이제 좀 쉬다가 다음 챕터 정리하러 가야겠다. 다음챕터는 트리구조이다. 정리해야할 정보들이 많아보인다 잘 준비해야겠다.

</details>

