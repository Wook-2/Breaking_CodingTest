### 시간 복잡도
**알고리즘의 시간복잡도와 Big-O표기법에 대해 간단히 알아본다.**

#### 알고리즘
알고리즘이란 어떠한 문제가 주어졌을 때 그 문제를 해결하기 위한 방법이다.<br>
같은 문제를 해결하는데에는 여러가지 방법이 있을 수 있겠다.<br>
그 여러가지 방법중에 가장 **빠르고** 힘 안들이는 방법이 당연히 좋을것이다.<br>
이 때 위에서 '**빠르고**'를 담당하는 알고리즘의 해결속도를 **시간 복잡도**라고한다.<br> 
<br>

연산 복잡도를 카운팅 할때에는 3가지 경우가 있다.

 - ##### 최선의 경우
	 - ##### 최선의 경우 오메가표기법으로 나타낸다 *(Big-Ω Notation)* .
 - ##### 평균적인 경우
	 - ##### 평균적인 경우 세타 표기법으로 나타낸다 *(Big-θ Notation)*.
 - ##### 최악의 경우
	 - ##### 최악의 경우 Big-O 표기법으로 나타낸다 *(Big -O Notation)*.
이 세가지 표기법중 **Big-O 표기법**을 주로 사용하는데 그 이유에 대해 생각해보았다.<br>
A라는 알고리즘은 처리해야하는 데이터의 량이 적을 때 매우 빠르지만 데이터가 점점 커질수록 느려진다.<br>
반면 B라는 알고리즘은 데이터가 작을때는 A알고리즘보다 속도가 느리지만 데이터가 커질수록 A보다 처리속도가 빨라진다고 해보자. <br>
<img src = "https://github.com/Wook-2/Breaking_CodingTest/blob/main/image/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84%20%EA%B7%B8%EB%9E%98%ED%94%84.png?raw=true" width = "500px"><br>
이때 A알고리즘의 최선의 경우가 B알고리즘의 최선의 경우보다 연산속도가 빠르다고 해서 A가 더 좋다고 볼 수 있을까..?<br>
대충 이런느낌(?) 으로 왜 최악의 경우를 나타내는 Big-O표기법을 주로 쓰는지 알고가면 좋을것같다.<br>
*( +점근적 분석을 키워드로 찾아보면 조금더 합리적이고 납득할만한 이유를 얻을 수 있을 듯 하다.)*<br>
아 그리고 이 글에서는 Big-O에 대해서만 다룰 것이다. <br>
 
 

#### Big-O 표기법
Big-O표기법은 위해서 말했다 시피 알고리즘의 효율성을 표기해주는 표기법이다.<br>
표기법은 : O(1), O(n), O(n^2) 와 같이 표기하면 된다. <br>
여기서 n은 알고리즘에 입력으로 들어오는 데이터? 의 양이라고 보면 되겠다.<br>
그렇다면 O(n)은 입력데이터가 n개 들어왔을 때 n만큼의 복잡도를 가지고, O(n^2)은 같은 n개의 데이터가 입력으로 들어왔을 때 n^2 만큼의 시간이 걸린다고 이해하면 될것같다.<br>
이 경우 당연히 같은 양의 데이터를 더 빨리 처리하는 O(n) 이  O(n^2)보다 효율적이라고 볼 수 있겠다.<br>
<br>
Big-O표기법에는 몇가지 특징이 있다.<br>

 - #### 상수항 무시 
	 - ##### O(3n) 같은 경우 앞의 상수항을 무시하고 O(n)으로 표기한다.
 - #### 최대차항만 기입
	 - ##### O(n^2 + 2n) 같은 경우 가장 복잡도에 영향을 많이받는 n^2만 남겨 O(n^2)으로 표기한다.

#### 코드에서의 시간복잡도
##### O(1) :
아래의 함수의 경우 입력값으로 n을 받았지만 n과 상관없이 한번의 반복문을 출력한다.<br>
이렇게 n값에 상관없이 상수값 만큼의 시간복잡도를 가지는 경우 O(1)의 시간복잡도를 가진다.

    def main(n):
	    print("hello world")
##### O(n)
입력값으로 n을 받았고 print() 함수가 n번 실행된다. <br>
이 경우 O(n)의 시간복잡도를 가진다.

    def loop(n):
	    for i in range(n):
		    print(i)
##### O(n^2)
입력값으로는 n을 받았지만 print()함수는 n^2번 호출된다.<br>
이런 경우 O(n^2)의 시간복잡도를 가진다.

    def 99dan(n):
	    for i in range(n):
		    for j in range(n):
			    print(i,"x",j,"=", i*j)
##### O(nlogn)
아래는 퀵정렬 코드이다. 퀵정렬은 길이가 n인 배열을 정렬하는데에 nlogn만큼의 시간복잡도를 가진다. <br>
이렇게 n개의 입력이 들어왔을 때 nlogn만큼의 시간이 걸리는 알고리즘의 경우 O(nlogn)의 시간복잡도를 가진다고 표기하면 된다.
```python
    def quick_sort(arr):
	    small = []
	    big = []
	    v = []
	    if len(arr) <= 1:
		    return arr
		pivot = arr[len(arr)//2]
		for i in arr:
			if i < pivot:
				small.append(i)
			elif i > pivot:
				big.append(i)
			else:
				v.append(i)
		return quick_sort(small) + v + quick_sort(big)
```			
   
   <br>
   각 시간복잡도의 성능은 아래의 표를 통해 눈으로 확인할 수 있다.
   <img src = "https://github.com/Wook-2/Breaking_CodingTest/blob/main/image/big-o.PNG?raw=true" width = "600px">
